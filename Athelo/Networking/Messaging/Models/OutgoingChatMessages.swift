//
//  File.swift
//  
//
//  Created by Krzysztof Jabłoński on 28/06/2022.
//

import Foundation

/// Defines messages that can be sent during active chat session.
public struct MessagingOutgoingChatSocketMessage {
    /// Describes type of message sent.
    public enum MessageType {
        /// Retrieves history of messages from given point in time, to number of messages bound by limit.
        case getHistory(timestamp: Int64, limit: Int)
        /// Retrieves last chat room message for given chat room.
        case getLastMessage
        /// Retrieves last messages read by each of participants.
        case getLastMessagesRead
        /// Retrieves number of unread messages for given chat rooms.
        case getUnreadMessagesCount
        /// Sends a message.
        case sendMessage(message: String)
        /// Sets message at given timestamp as read.
        case setLastMessageRead(timestamp: Int64)

        var code: String {
            switch self {
            case .getHistory:
                return "GET_HISTORY"
            case .getLastMessage:
                return "GET_LAST_CHAT_ROOM_MESSAGE"
            case .getLastMessagesRead:
                return "GET_LAST_MESSAGES_READ"
            case .getUnreadMessagesCount:
                return "GET_UNREAD_MESSAGES_COUNT"
            case .sendMessage:
                return "ROUTABLE"
            case .setLastMessageRead:
                return "SET_LAST_MESSAGE_READ"
            }
        }

        fileprivate var expectsMultiRoomInput: Bool {
            switch self {
            case .getHistory, .getLastMessagesRead, .sendMessage, .setLastMessageRead:
                return false
            case .getLastMessage, .getUnreadMessagesCount:
                return true
            }
        }
    }

    /// Room identifier for which message should be resolved against.
    public let chatRoomID: String
    /// Type of posted message.
    public let type: MessageType
    
    public init(type: MessageType, chatRoomID: String) {
        self.chatRoomID = chatRoomID
        self.type = type
    }

    /// Converts any data held into valid JSON object data.
    ///
    /// - Throws: Any encoding error generated by providing invalid values.
    ///
    /// - Returns: A valid `Data` object containing JSON data.
    func toJSONData() throws -> Data {
        try JSONSerialization.data(withJSONObject: toJSONDict(), options: [])
    }

    /// Converts any data held into valid JSON object dict.
    ///
    /// - Returns: A valid `Dictionary` object containing JSON data.
    func toJSONDict() -> [String: Any] {
        var encodedData: [String: Any] = [
            "type": type.code
        ]

        if type.expectsMultiRoomInput {
            encodedData["chat_room_identifiers"] = [chatRoomID]
        } else {
            encodedData["chat_room_identifier"] = chatRoomID
        }

        switch type {
        case .getHistory(let timestamp, let limit):
            encodedData["from_message_timestamp_identifier"] = timestamp
            encodedData["limit"] = limit
        case .getLastMessage, .getLastMessagesRead, .getUnreadMessagesCount:
            break
        case .sendMessage(let message):
            encodedData["message"] = message
        case .setLastMessageRead(let timestamp):
            encodedData["message_timestamp_identifier"] = timestamp + 1
        }

        return encodedData
    }
}
